# 概念
全排列的生成算法有很多种，有递归遍例，也有循环移位法等等。C++/STL中定义的next_permutation和prev_permutation函数则是非常灵活且高效的一种方法，它被广泛的应用于为指定序列生成不同的排列。本文将详细的介绍prev_permutation函数的内部算法。

按照STL文档的描述，next_permutation函数将按字母表顺序生成给定序列的下一个较大的序列，直到整个序列为减序为止。prev_permutation函数与之相反，是生成给定序列的上一个较小的序列。二者原理相同，仅遍例顺序相反，这里仅以next_permutation为例介绍算法。

下文内容都基于一个假设，即序列中不存在相同元素。对序列大小的比较做出定义：两个长度相同的序列，从两者的第一个元素开始向后比较，直到出现一个不同元素（也可能就是第它们的第一个元素），该元素较大的序列为大，反之序列为小；若一直到最后一个元素都相同，那么两个序列相等。

设当前序列为pn，下一个较大的序列为pn+1，那么不存在pm，使得pn < pm < pn+1。

# permutation相关问题
### 1、求集合{1, 2, ..., m}的第n个排列
### 2、给定一种排列，如何算出这是第几个排列
### 3、生成下一个排列

##  1、求集合{1, 2, ..., m}的第n个排列
设某个集合{a1, a2, ..., am}（a1<a2<...<am）构成的某种序列pn，基于以上分析易证得：若as<at，那么将as作为第1个元素的所有序列一定都小于at作为第1个元素的任意序列。同理可证得：第1个元素确定后，剩下的元素中若as'<at'，那么将as'作为第2个元素的所有序列一定都小于作为第2个元素的任意序列。例如4个数的集合{2, 3, 4, 6}构成的序列中，以3作为第1个元素的序列一定小于以4或6作为第1个元素的序列；3作为第1个元素的前题下，2作为第2个元素的序列一定小于以4或6作为第2个元素的序列。

推广可知，在确定前i（i<n）个元素后，在剩下的m-i=s个元素的集合{aq1, aq2, ..., aq3}（aq1<aq2<...<aqm）中，以aqj作为第i+1个元素的序列一定小于以aqj+1作为第i+1个元素的序列。由此可知：在确定前i个元素后，一共可生成s!种连续大小的序列。

根据以上分析，对于给定的n（必有n<=m!）可以从第1位开始向右逐位地确定每一位元素。在第1位不变的前题下，后面m-1位一共可以生成(m-1)!中连续大小的序列。若n>(m-1)!，则第1位不会是a1，n中可以容纳x个(m-1)!即代表第1位是ax。在确定第1位后，将第1位从原集合中删除，得到新的集合{aq1, aq2, ..., aq3}（aq1<aq2<...<aqm），然后令n1=n-x(m-1)!，求这m-1个数中生成的第n1个序列的第1位。

举例说明：如7个数的集合为{1, 2, 3, 4, 5, 6, 7}，要求出第n=1654个排列。

(1654 / 6!)取整得2，确定第1位为3，剩下的6个数{1, 2, 4, 5, 6, 7}，求第1654 % 6!=214个序列；

(214 / 5!)取整得1，确定第2位为2，剩下5个数{1, 4, 5, 6, 7}，求第214 % 5!=94个序列；

(94 / 4!)取整得3，确定第3位为6，剩下4个数{1, 4, 5, 7}，求第94 % 4!=22个序列；

(22 / 3!)取整得3，确定第4位为7，剩下3个数{1, 4, 5}，求第22 % 3!=4个序列；

(4 / 2!)得2，确定第5为5，剩下2个数{1, 4}；由于4 % 2!=0，故第6位和第7位为增序<1 4>；

因此所有排列为：3267514。

## 2、给定一种排列，如何算出这是第几个排列
和前一个问题的推导过程相反。例如3267514：

后6位的全排列为6!，3为{1, 2, 3 ,4 , 5, 6, 7}中第2个元素（从0开始计数），故2*720=1440；

后5位的全排列为5!，2为{1, 2, 4, 5, 6, 7}中第1个元素，故1*5!=120；

后4位的全排列为4!，6为{1, 4, 5, 6, 7}中第3个元素，故3*4!=72；

后3位的全排列为3!，7为{1, 4, 5, 7}中第3个元素，故3*3!=18；

后2位的全排列为2!，5为{1, 4, 5}中第2个元素，故2*2!=4；

最后2位为增序，因此计数0，求和得：1440+120+72+18+4=1654

## 3、生成下一个排列
如果一个排列为A，下一个排列为A_NEXT，那么A_NEXT一定与A有尽可能长的公共前缀。
看具体例子，一个排列为124653，如何找到它的下一个排列，因为下一个排列一定与124653有尽可能长的前缀，所以，脑洞大开一下，从后面往前看这个序列，如果后面的若干个数字有下一个排列，问题就得到了解决。
- 第一步：找最后面1个数字的下一个全排列。
124653，显然最后1个数字3不具有下一个全排列。
- 第二步：找最后面2个数字的下一个全排列。
124653，显然最后2个数字53不具有下一个全排列。
- 第三步：找最后面3个数字的下一个全排列。
124653，显然最后3个数字653不具有下一个全排列。
- 第四步：找最后面4个数字的下一个全排列。
124653，我们发现显然最后4个数字4653具有下一个全排列。因为它不是递减的，例如6453，5643这些排列都在4653的后面。

我们总结上面的操作，并总结出重复上面操作的两种终止情况：
- 1：从后向前比较相邻的两个元素，直到前一个元素小于后一个元素，停止
- 2：如果已经没有了前一个元素，则说明这个排列是递减的，所以这个排列是没有下一个排列的。

124653这个排列终止情况是上面介绍的第一种，从后向前比较相邻的2个元素，遇到4<6的情况停止。
并且我们可以知道：
- 1：124653和它的下一个排列的公共前缀为12(因为4653存在下一个排列，所以前面的数字12保持不变)
- 2：4后面的元素是递减的(上面介绍的终止条件是前一个元素小于后一个元素，这里是4<6)

 现在，我们开始考虑如何找到4653的下个排列，首先明确4后面的几个数字中至少有一个大于4.
4肯定要和653这3个数字中大于4的数字中(6，5)的某一个进行交换。这里就是4要和6，5中的某一个交换，很明显要和5交换，如果找到这样的元素呢，因为我们知道4后面的元素是递减的，所以在653中从后面往前查找，找到第一个大于4的数字，这就是需要和4进行交换的数字。这里我们找到了5，交换之后得到的临时序列为5643.，交换后得到的643也是一个递减序列。

所以得到的4653的下一个临时序列为5643，但是既然前面数字变大了(4653--->5643)，后面的自然要变为升序才行，变换5643得到5346.
所以124653的下一个序列为125643.

